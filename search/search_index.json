{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Cppinecone provides a simple API for C++ applications to interact with the Pinecone vector database.</p> <p>To learn about the details of the Pinecone API, please see their reference documentation.</p> <p>While I recommend starting with the quick start guide, you may also wish to take a look at the client, which serves as the entry-point to the API and is the primary public interface for users of Cppinecone.</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Cppinecone is in a relatively early state of development. The client-facing API should remain relatively stable (at least as stable as the Pinecone API itself), but bugs are certainly possible. The client has not been highly optimized and most API operations will heap allocate - this allocation is not strictly required and could eventually be controlled by the user if the needs arises.</p>"},{"location":"#design-decisions","title":"Design decisions","text":"<p>Cppinecone makes a small number of design decisions that users may wish to be aware of:</p> <ul> <li>The client will never throw exceptions</li> <li>Fallible operations will always return a   result</li> </ul> <p>These decisions can be modified through the use of API customizations.</p>"},{"location":"#known-issues","title":"Known issues","text":"<ul> <li>Rarely, the Pinecone API will return 50X errors for operations run against an index/collection too soon after its   initialization is complete. This is a problem with the Pinecone API itself, and not something that Cppinecone can   control</li> <li>Some Pinecone API operations seem to return undocumented data with their results. Cppinecone provides support only for   data explicitly documented in Pinecone's API reference</li> <li>Cppinecone has been tested only on Debian-based Linux distributions using the Clang compiler. Other platforms and   compilers should be supported, but this support has not been verified. If you find compatibility issues, please create   an issue.</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Cppinecone aims to minimize dependencies, both those required by users and those used to construct the client API. Currently, Cppinecone carries the following required dependencies:</p> <ul> <li>Required at run-time<ul> <li>CURL for http communication</li> </ul> </li> <li>Used within the client implementation<ul> <li>nlohmann/json for JSON serde</li> <li>spdlog for logging</li> <li>Catch2 for unit testing</li> </ul> </li> </ul> <p>More information about these dependencies and what they mean for users can be found in the installation documentation.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>Code-level details for Cppinecone can be found in the API reference documentation.</p>"},{"location":"customization/","title":"API customization","text":""},{"location":"customization/#policies","title":"Policies","text":"<p>While Cppinecone has sensible defaults that should be appropriate for most use cases, we recognize that some users may have differing needs or technical constraints. The API supports compile-time customization through policies that allow control over the following behaviors:</p> <p>These policies are not yet implemented, but should be coming soon.</p> <ul> <li>Failure handling: for users who would prefer exceptions to the <code>result</code> API</li> <li>Allocation: for users who require fine-grained control over memory allocation strategies</li> </ul>"},{"location":"customization/#example","title":"Example","text":""},{"location":"customization/#logging","title":"Logging","text":"<p>Cppinecone uses spdlog for logging. By default, no logger will be configured, so it is completely up to the user to configure logging if they wish to capture Cppinecone's diagnostic output. Note that logs are not considered a public API surface, meaning that the logs written by Cppinecone should never be relied upon for any automated purpose. Written logs may change with any release, including patch releases.</p> <p>See the logging file for full details.</p> <p>Note that logging is currently not particularly useful. It should be improved in the near future.</p>"},{"location":"customization/#example_1","title":"Example","text":"<pre><code>#include &lt;pinecone/pinecone.hpp&gt;\n#include &lt;pinecone/util/logging.hpp&gt;\n#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;\nstatic inline void example() noexcept\n{\npinecone::util::setup_logger([](auto const&amp; name) {\nreturn spdlog::stdout_color_mt(name);\n});\npinecone::synchronous_client client = // ...\n}\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Cppinecone currently supports integration into other projects via CMake. Conan integration is planned for the future, but is not yet supported.</p>"},{"location":"installation/#cmake","title":"CMake","text":"<p>To integrate Cppinecone into a CMake project, you should use FetchContent to automatically download and link the desired version of the library.</p>"},{"location":"installation/#example","title":"Example","text":"<p>The examples directory contains a complete example of Cppinecone integration into another project. Most users will want to use a versioned tag to ensure library stability. By default, tests and the executable harness are not built. There is generally no reason for end-users to desire these targets.</p> <pre><code>cmake_minimum_required(VERSION 3.20)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED on)\nset(CMAKE_CXX_EXTENSIONS off)\nset(CMAKE_BUILD_TYPE Debug)\nproject(cppinecone_examples)\ninclude(FetchContent)\nFetchContent_Declare(libcppinecone\nGIT_REPOSITORY https://github.com/jkaye2012/cppinecone.git\nGIT_TAG v0.1.0)\nFetchContent_Populate(libcppinecone)\nadd_subdirectory(${libcppinecone_SOURCE_DIR})\nadd_executable(cppinecone_examples_exe main.cpp)\ntarget_include_directories(main PRIVATE ${CPPINECONE_INCLUDE_DIRS})\ntarget_link_libraries(main PRIVATE ${CPPINECONE_LIBRARIES})\n</code></pre> <p>Cppinecone should now be available via <code>#include &lt;pinecone/pinecone.hpp&gt;</code>.</p>"},{"location":"installation/#dependency-configuration","title":"Dependency configuration","text":"<p>By default, Cppinecone's CURL configuration assumes that OpenSSL should be used for TLS, and that the library is available for linking when CURL is being built.</p> <p>Three third-party libraries are vended with Cppinecone for ease of use. The configuration of these libraries can be controlled by the user by setting their supported CMake variables. For most users, the library defaults should be reasonable.</p> <ul> <li>CURL's supported variables are unfortunately not well-documented. You can find them directly in the   CMakeLists.txt file in their main repository</li> <li>JSON's CMake support is well-documented</li> <li>Spdlog does not require CMake configuration</li> </ul>"},{"location":"metadata_query_api/","title":"Metadata Query API","text":""},{"location":"metadata_query_api/#formal-specification","title":"Formal specification","text":"<p>Metadata filtering is one of the more complicated aspects of Pinecone's REST API. This section describes the approach taken by Cppinecone more formally for those who are interested in the inner workings of the API.</p> <p>The following EBNF grammar defines the structure enforced by Cppinecone's API constructs:</p> <pre><code>eq = \"$eq\";\nne = \"$ne\";\ngt = \"$gt\";\ngte = \"$gte\";\nlt = \"$lt\";\nlte = \"$lte\";\nin = \"$in\";\nnin = \"$nin\";\nand = \"$and\";\nor = \"$or\";\nbin_op = eq | ne | gt | gte | lt | lte;\nvar_op = in | nin;\ncom_op = and | or;\nstr = ?quoted Pinecone string?;\nnum = ?Pinecone number?;\nbool = true | false;\nmeta_key = str;\nmeta_val = num | str | bool;\nmeta_arr = \"[\", meta_val, {\", \", meta_val}, \"]\";\nbin_pred = \"{\", meta_key, \": {\", bin_op, \": \", meta_val, \"}}\";\nvar_pred = \"{\", meta_key, \": {\", var_op, \": \", meta_arr, \"}}\";\ncom_pred = \"{\", com_op, \": \", com_arr, \"}\";\ncom_arr = \"[\", pred, {\", \", pred} \"]\";\npred = bin_pred | var_pred | com_pred;\nfilter = '{ \"filter\": ', pred, '}';\n</code></pre> <p>Note that this grammar does not exactly match the filters supported by Pinecone's API natively! While Pinecone technically does provide other mechanisms to express these filters, the grammar used by Cppinecone is comprehensive enough to encode any filter expression supported by Pinecone while also maintaining a level of simplicity that makes the API much easier to work with than it would be otherwise.</p> <p>From the grammar, it's apparent that the necessary rules are simpler than they appear. The API supports only three types of operations:</p> <ol> <li>Binary predicates: <code>eq</code>, <code>ne</code>, <code>gt</code>, <code>gte</code>, <code>lt</code>, and <code>lte</code></li> <li>N-ary predicates: <code>in</code> and <code>nin</code></li> <li>Combination predicates: <code>and</code> and <code>or</code></li> </ol> <p>Binary and N-ary predicates can be thought of as atoms, meaning that they cannot be decomposed into smaller operations, while Combination predicates are instead productions, meaning that they are always composed of two other predicates. We can therefore describe metadata filters using prefix notation so that operator precedence is handled automatically by filter construction.</p> <p>This insight is the core of Cppinecone's metadata filtering API. Filters are constructed as an N-ary tree with a single root where all leaves form atomic operations. A depth-first traversal of the tree thus automatically constructs the prefix notation. This construction also allows the API to easily leverage lazy evaluation, meaning that each filter constructed by a user requires only a single allocation step.</p>"},{"location":"metadata_query_api/#example","title":"Example","text":"<p>We demonstrate application of both simple and compound predicate filters. This example should be able to be compiled and run assuming that Cppinecone has been installed. The example assumes that the provided API key has access to an index named <code>squad</code> created from the <code>SQuAD</code> public collection.</p> <pre><code>#include &lt;cassert&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;variant&gt;\n#include &lt;pinecone/pinecone.hpp&gt;\nstatic inline void run_metadata_example(pinecone::synchronous_client const&amp; client) noexcept\n{\nauto comic_filter = pinecone::types::filters::eq(\"title\", \"Marvel_Comics\");\nauto result =\nclient.query(\"squad\", pinecone::types::query_builder(comic_filter, 1000, \"9833\").build());\nassert(result.is_successful());\nstd::cout &lt;&lt; \"Marvel comic results: \" &lt;&lt; result-&gt;query_matches().size() &lt;&lt; std::endl;\nauto ps_filter = pinecone::types::filters::eq(\"title\", \"PlayStation_3\");\nauto combined_filter = pinecone::types::filters::or_(comic_filter, ps_filter);\nauto combined_result =\nclient.query(\"squad\", pinecone::types::query_builder(combined_filter, 1000, \"9833\").build());\nassert(combined_result.is_successful());\nstd::cout &lt;&lt; \"Marvel comic or playstation results: \" &lt;&lt; combined_result-&gt;query_matches().size()\n&lt;&lt; std::endl;\n}\nint main(int argc, char** argv)\n{\nassert(argc == 3);\nauto client = std::get&lt;0&gt;(pinecone::synchronous_client::build({argv[1], argv[2]}));\nrun_metadata_example(client);\nreturn 0;\n}\n</code></pre>"},{"location":"quickstart/","title":"Quick start guide","text":"<p>One of Cppinecone's primary design goals is to be as simple as possible for basic usage. There are only two requirements to interact with the Pinecone API:</p> <ul> <li>You must know the environment (region) that you wish to interact with</li> <li>You must have access to a Pinecone API key with appropriate permissions</li> </ul> <p>This information is required by Pinecone itself - Cppinecone doesn't carry any of its own requirements at run time.</p>"},{"location":"quickstart/#download-and-install","title":"Download and install","text":"<p>Cppinecone must be integrated into your application before it can be used. Please see the installation documentation for more details.</p>"},{"location":"quickstart/#create-a-client","title":"Create a client","text":"<p>All API access is performed through a <code>pinecone_client</code> instance. Currently only a synchronous client is supported; there are plans for an asynchronous option in the future.</p> <pre><code>#include &lt;pinecone/pinecone.hpp&gt;\nauto client = std::move(std::get&lt;pinecone::synchronous_client&gt;(pinecone::synchronous_client::build({\"us-west1-gcp\", \"api_key_goes_here\"})));\n</code></pre> <p>Note that it is technically possible for client creation to fail, so the <code>build</code> function returns a variant. Client construction failure is possible only due to a system configuration problem (usually, a CURL version mismatch), so this possibility can be safely ignored in many situations. If you're in control of the systems that your code will be run on, you can safely extract the constructed client from the variant without further checks.</p>"},{"location":"quickstart/#run-a-collection-operation","title":"Run a collection operation","text":"<p>Let's use the client to find the collections available to us:</p> <pre><code>auto collections = client.list_collections();\nif(collections) {\nstd::cout &lt;&lt; \"Number of collections: \" &lt;&lt; collections-&gt;names().size() &lt;&lt; std::endl; // Requires &lt;iostream&gt;\n} else {\nstd::cerr &lt;&lt; \"Failed to list collections: \" &lt;&lt; collections.to_string() &lt;&lt; std::endl;\n}\n</code></pre> <p>Most Cppinecone operations are as simple as this: create a client once somewhere within your application, then run all future operations using the single client instance. Multiple client instances are required only for concurrent requests, or when access to multiple environments/API keys are necessary.</p> <p>The synchronous client is not thread-safe; if multiple threads require Pinecone access, either create a client per thread or ensure that the client is protected by a mutex. Once the asynchronous client is released, this restriction will be lifted.</p> <p>All API operations by default return a result. <code>result</code> models the possibility of failure; as all API operations require network access, they are all fallible. <code>result</code> is implicitly <code>nodiscard</code>, meaning that your compiler will warn you if you accidentally forget to ensure that an operation was successful.</p> <p>Note that even though Cppinecone itself does not throw exceptions by default, it cannot be compiled with <code>no-exceptions</code> due to carried dependencies that are incompatible with that compilation option.</p> <p>If you'd prefer exceptions to the <code>result</code> construction, please see the API customization documentation for the other available failure handling policies.</p>"},{"location":"quickstart/#run-a-vector-operation","title":"Run a vector operation","text":"<p>Vector operations are very similar to collection operations. All vector operations require the index name to be provided:</p> <pre><code>auto stats = client.describe_index_stats(\"squad\");\nif(stats) {\nstd::cout &lt;&lt; \"Number of namespaces: \" &lt;&lt; stats-&gt;namespaces().size() &lt;&lt; std::endl;\n} else {\nstd::cerr &lt;&lt; \"Failed to describe stats: \" &lt;&lt; stats.to_string() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next steps","text":"<p>This is all you need to know to use Cppinecone! For more information about the available operations and other in-depth details, check out the rest of the documentation:</p> <ul> <li>API reference</li> <li>Metadata query API</li> <li>API customization</li> </ul>"},{"location":"quickstart/#complete-code-example","title":"Complete code example","text":"<p>This snippet can be compiled and run directly.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;variant&gt;\n#include &lt;pinecone/pinecone.hpp&gt;\nint main(int argc, char** argv) {\nif(argc != 2) {\nstd::cerr &lt;&lt; \"Please provide Pinecone environment and API key as parameters\" &lt;&lt; std::endl;\nreturn 1;\n}\nauto client_build = pinecone::synchronous_client::build({argv[1], argv[2]});\nif(!std::holds_alternative&lt;pinecone::synchronous_client&gt;(client_build)) {\nstd::cerr &lt;&lt; \"Failed to create client: \" &lt;&lt; std::get&lt;std::string&gt;(client_build) &lt;&lt; std::endl;\nreturn 2;\n}\nauto client = std::move(std::get&lt;pinecone::synchronous_client&gt;(client_build));\nauto collections = client.list_collections();\nif(collections) {\nstd::cout &lt;&lt; \"Number of collections: \" &lt;&lt; collections-&gt;names().size() &lt;&lt; std::endl;\n} else {\nstd::cerr &lt;&lt; \"Failed to list collections: \" &lt;&lt; collections.to_string() &lt;&lt; std::endl;\n}\nauto stats = client.describe_index_stats(\"squad\");\nif(stats) {\nstd::cout &lt;&lt; \"Number of namespaces: \" &lt;&lt; stats-&gt;namespaces().size() &lt;&lt; std::endl;\n} else {\nstd::cerr &lt;&lt; \"Failed to describe stats: \" &lt;&lt; stats.to_string() &lt;&lt; std::endl;\n}\nreturn 0;\n}\n</code></pre>"},{"location":"development/architecture/","title":"Architecture","text":"<p>The most important tenet of Cppinecone's architecture is that using the library must be simple for end users. Users generally do not care about details of how the client works internally, nor should the library prescribe specific behaviors or methodologies on our users whenever possible. With this in mind, the most important concept in the architecture is:</p> <ul> <li>The public client API</li> </ul> <p>The client API is in turn driven by a small number of \"top-level\" concepts that allow for easy implementation of communication with Pinecone's REST API:</p> <ul> <li>URL construction</li> <li>HTTP communication</li> </ul> <p>Finally, we must encode the data structures and communication protocols for each operation that the Pinecone API supports. This is provided by:</p> <ul> <li>Individual API operations</li> </ul> <p>Each of these concepts is briefly explained here. The purpose of this document is to provide a high-level overview of why the code is structured in this way; it does not attempt to explain how each individual component works or why low-level implementation details were chosen.</p>"},{"location":"development/architecture/#the-public-client-api","title":"The public client API","text":"<p>The public client API is meant to be the primary (and, for now, only) entrypoint into Cppinecone. Users should not be required to use anything other than a client to access basic API functionality. Similarly, customizations applied to the API should be applied to the client instance so that instantiation remains simple and confined to a single concept within the code base.</p>"},{"location":"development/architecture/#url-construction","title":"URL construction","text":"<p>Perhaps surprisingly, URL construction for Pinecone's REST APIs is non-trivial. Different API operation require significantly different URL fragments, and many operations require metadata that must be retrieved from the API itself. These operation-level details are abstracted from client APIs and HTTP communication by the concept of opaque URL construction for each individual operation. This functionality is provided by the url_builder.</p>"},{"location":"development/architecture/#http-communication","title":"HTTP communication","text":"<p>One of the simplest parts of Cppinecone, libcurl is used to perform the actual HTTP requests to Pinecone's REST API. The http_client concept exists to abstract away the low-level details of CURL's APIs from the rest of Cppinecone's implementation. This also provides a convenient location for unified serde operations and consistent error handling across all API operations.</p>"},{"location":"development/architecture/#individual-api-operations","title":"Individual API operations","text":"<p>Each API operation is implemented independently, but in terms of shared concepts that remove the need for boilerplate/repetition. The definitions for these concepts are stored together.</p> <p>Generally speaking, the steps required to implement a new API operation are:</p> <ol> <li>Add the operation definition as a supported <code>operation_type</code></li> <li>Map the new <code>operation_type</code> to an API type</li> <li>Map the new <code>operation_type</code> to a url fragment</li> <li>Map the new <code>operation_type</code> to an HTTP method</li> <li>Define any custom C++ types necessary to represent the operation request/response</li> <li>Wire up the operation</li> <li>Expose the operation via a new function on the public client</li> </ol> <p>Cppinecone buckets API operations into three different categories:</p> <ul> <li>Metadata operations: provide information about the Pinecone API itself</li> <li>Index operations: CRUD operations on Pinecone indices and collections</li> <li>Vector operations: CRUD operations on individual vectors within indices   and collections</li> </ul> <p>The relationship between the API operation categories and the remainder of Cppinecone can be visualized with the file include diagram available within the generated documentation.</p>"},{"location":"development/development_environment/","title":"Development environment","text":"<p>Cppinecone ships with a fully-instrumented development environment for VSCode driven by Devcontainers. If you have the devcontainers extension installed, VSCode should prompt you to open the project in a devcontainer when you open the repository in a workspace.</p>"},{"location":"development/development_environment/#tasks","title":"Tasks","text":"<p>Pre-configured tasks for commonly used development operations:</p> <ul> <li><code>build</code>: builds the library. Can be manually executed via <code>run_build.sh</code></li> <li><code>test</code>: runs tests for the library. Note that Pinecone API keys must be provided (trying to run the tests without a   key will display an error message with details). Can be manually executed via <code>run_tests.sh</code></li> <li><code>docs</code>: builds documentation and runs the mkdocs site, including Doxygen generation and hosting. Port 8000 is   automatically forwarded to your local machine for ease of browsing. Can be manually executed via <code>run_docs.sh</code></li> </ul>"},{"location":"development/development_environment/#intellisense-linting-auto-formatting","title":"Intellisense, linting, auto-formatting","text":"<p>Standard editor functionality is provided via the clangd extension which is driven by the <code>compile_commands.json</code> compilation database. This file is generated by the build, so it is necessary to build the library at least once before editor tooling will function properly. An initial can be run using the default build task (<code>Ctrl-Shift-B</code>).</p>"}]}